<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <div style="font-size: 20px;">
            <a href="#oops">Opps</a><br>
            <a href="#interface ">interface</a><br>
            <a href="#instance">instance</a>
        </div>
        <div id="oops">
            <h1 style="text-align: center;background-color: blue;color: aliceblue;">Opps</h1>
            <p>As the name suggests, Object-Oriented Programming or OOPs refers
                to languages that use objects in programming. Object-oriented
                programming aims to implement real-world entities like
                inheritance, hiding, polymorphism, etc in programming. The main
                aim of OOP is to bind together the data and the functions that
                operate on them so that no other part of the code can access
                this data except that function.

                OOPs Concepts:

                Class
                Objects
                Data Abstraction
                Encapsulation
                Inheritance
                Polymorphism
                Dynamic Binding
                Message Passing
                1. Class:

                A class is a user-defined data type. It consists of data members
                and member functions, which can be accessed and used by creating
                an instance of that class. It represents the set of properties
                or methods that are common to all objects of one type. A class
                is like a blueprint for an object.

                For Example: Consider the Class of Cars. There may be many cars
                with different names and brands but all of them will share some
                common properties like all of them will have 4 wheels, Speed
                Limit, Mileage range, etc. So here, Car is the class, and
                wheels, speed limits, mileage are their properties.

                2. Object:

                It is a basic unit of Object-Oriented Programming and represents
                the real-life entities. An Object is an instance of a Class.
                When a class is defined, no memory is allocated but when it is
                instantiated (i.e. an object is created) memory is allocated. An
                object has an identity, state, and behavior. Each object
                contains data and code to manipulate the data. Objects can
                interact without having to know details of each other’s data or
                code, it is sufficient to know the type of message accepted and
                type of response returned by the objects.

                For example “Dog” is a real-life Object, which has some
                characteristics like color, Breed, Bark, Sleep, and Eats.

                Object in OOPs
                Object

                3. Data Abstraction:

                Data abstraction is one of the most essential and important
                features of object-oriented programming. Data abstraction refers
                to providing only essential information about the data to the
                outside world, hiding the background details or implementation.
                Consider a real-life example of a man driving a car. The man
                only knows that pressing the accelerators will increase the
                speed of the car or applying brakes will stop the car, but he
                does not know about how on pressing the accelerator the speed is
                increasing, he does not know about the inner mechanism of the
                car or the implementation of the accelerator, brakes, etc in the
                car. This is what abstraction is.

                4. Encapsulation:

                Encapsulation is defined as the wrapping up of data under a
                single unit. It is the mechanism that binds together code and
                the data it manipulates. In Encapsulation, the variables or data
                of a class are hidden from any other class and can be accessed
                only through any member function of their class in which they
                are declared. As in encapsulation, the data in a class is hidden
                from other classes, so it is also known as data-hiding.

                Encapsulation in Object Oriented Programming

                Consider a real-life example of encapsulation, in a company,
                there are different sections like the accounts section, finance
                section, sales section, etc. The finance section handles all the
                financial transactions and keeps records of all the data related
                to finance. Similarly, the sales section handles all the
                sales-related activities and keeps records of all the sales. Now
                there may arise a situation when for some reason an official
                from the finance section needs all the data about sales in a
                particular month. In this case, he is not allowed to directly
                access the data of the sales section. He will first have to
                contact some other officer in the sales section and then request
                him to give the particular data. This is what encapsulation is.
                Here the data of the sales section and the employees that can
                manipulate them are wrapped under a single name “sales section”.

                5. Inheritance:

                Inheritance is an important pillar of OOP(Object-Oriented
                Programming). The capability of a class to derive properties and
                characteristics from another class is called Inheritance. When
                we write a class, we inherit properties from other classes. So
                when we create a class, we do not need to write all the
                properties and functions again and again, as these can be
                inherited from another class that possesses it. Inheritance
                allows the user to reuse the code whenever possible and reduce
                its redundancy.

                Interitance in Object Oriented Programming

                6. Polymorphism:

                The word polymorphism means having many forms. In simple words,
                we can define polymorphism as the ability of a message to be
                displayed in more than one form. For example, A person at the
                same time can have different characteristics. Like a man at the
                same time is a father, a husband, an employee. So the same
                person posses different behavior in different situations. This
                is called polymorphism.

                Polymorphism in OOPs

                7. Dynamic Binding:

                In dynamic binding, the code to be executed in response to the
                function call is decided at runtime. Dynamic binding means that
                the code associated with a given procedure call is not known
                until the time of the call at run time. Dynamic Method Binding
                One of the main advantages of inheritance is that some derived
                class D has all the members of its base class B. Once D is not
                hiding any of the public members of B, then an object of D can
                represent B in any context where a B could be used. This feature
                is known as subtype polymorphism.

                8. Message Passing:

                It is a form of communication used in object-oriented
                programming as well as parallel programming. Objects communicate
                with one another by sending and receiving information to each
                other. A message for an object is a request for execution of a
                procedure and therefore will invoke a function in the receiving
                object that generates the desired results. Message passing
                involves specifying the name of the object, the name of the
                function, and the information to be sent.

                Why do we need object-oriented programming

                To make the development and maintenance of projects more
                effortless.
                To provide the feature of data hiding that is good for security
                concerns.
                We can solve real-world problems if we are using object-oriented
                programming.
                It ensures code reusability.
                It lets us write generic code: which will work with a range of
                data, so we don’t have to write basic stuff over and over again.
                Whether you're preparing for your first job interview or aiming
                to upskill in this ever-evolving tech landscape, GeeksforGeeks
                Courses are your key to success. We provide top-quality content
                at affordable prices, all geared towards accelerating your
                growth in a time-bound manner. Join the millions we've already
                empowered, and we're here to do the same for you. Don't miss out
                - check it out now!</p>
        </div>
        <div id="interface">
            <h1 style="text-align: center;background-color: blue;color: aliceblue;">Interface</h1>
            <p>An Interface in Java programming language is defined as an
                abstract type used to specify the behavior of a class. An
                interface in Java is a blueprint of a behavior. A Java interface
                contains static constants and abstract methods.

                What are Interfaces in Java?
                The interface in Java is a mechanism to achieve abstraction.
                There can be only abstract methods in the Java interface, not
                the method body. It is used to achieve abstraction and multiple
                inheritances in Java using Interface. In other words, you can
                say that interfaces can have abstract methods and variables. It
                cannot have a method body. Java Interface also represents the
                IS-A relationship.

                When we decide on a type of entity by its behavior and not via
                attribute we should define it as an interface.

                Features of Interfaces

                Syntax for Java Interfaces
                interface {

                // declare constant fields
                // declare methods that abstract
                // by default.
                }
                To declare an interface, use the interface keyword. It is used
                to provide total abstraction. That means all the methods in an
                interface are declared with an empty body and are public and all
                fields are public, static, and final by default. A class that
                implements an interface must implement all the methods declared
                in the interface. To implement the interface use the implements
                keyword.

                Uses of Interfaces in Java
                Uses of Interfaces in Java are mentioned below:

                It is used to achieve total abstraction.
                Since java does not support multiple inheritances in the case of
                class, by using an interface it can achieve multiple
                inheritances.
                Any class can extend only 1 class but can any class implement an
                infinite number of interface.
                It is also used to achieve loose coupling.
                Interfaces are used to implement abstraction.
                So the question arises why use interfaces when we have abstract
                classes?

                The reason is, abstract classes may contain non-final variables,
                whereas variables in the interface are final, public, and
                static.

                // A simple interface

                interface Player
                {
                final int id = 10;
                int move();
                }
                Relationship Between Class and Interface
                A class can extend another class similar to this an interface
                can extend another interface. But only a class can extend to
                another interface, and vice-versa is not allowed.

                Relationship between Class and Interface

                Difference Between Class and Interface
                Although Class and Interface seem the same there have certain
                differences between Classes and Interface. The major differences
                between a class and an interface are mentioned below:

                Class

                Interface

                In class, you can instantiate variables and create an object. In
                an interface, you can’t instantiate variables and create an
                object.
                A class can contain concrete(with implementation) methods The
                interface cannot contain concrete(with implementation) methods
                The access specifiers used with classes are private, protected,
                and public. In Interface only one specifier is used- Public.
                Implementation: To implement an interface we use the keyword
                implements

                // Java program to demonstrate working of
                // interface

                import java.io.*;

                // A simple interface
                interface In1 {

                // public, static and final
                final int a = 10;

                // public and abstract
                void display();
                }

                // A class that implements the interface.
                class TestClass implements In1 {

                // Implementing the capabilities of
                // interface.
                public void display(){
                System.out.println("Geek");
                }

                // Driver Code
                public static void main(String[] args)
                {
                TestClass t = new TestClass();
                t.display();
                System.out.println(a);
                }
                }
                Output
                Geek
                10
                Java Interfaces Examples
                Let’s consider the example of vehicles like bicycles, cars,
                bikes, etc they have common functionalities. So we make an
                interface and put all these common functionalities. And lets
                Bicycle, Bike, car, etc implement all these functionalities in
                their own class in their own way.

                Below is the implementation of the above topic:

                // Java program to demonstrate the
                // real-world example of Interfaces

                import java.io.*;

                interface Vehicle {

                // all are the abstract methods.
                void changeGear(int a);
                void speedUp(int a);
                void applyBrakes(int a);
                }

                class Bicycle implements Vehicle{

                int speed;
                int gear;

                // to change gear
                @Override
                public void changeGear(int newGear){

                gear = newGear;
                }

                // to increase speed
                @Override
                public void speedUp(int increment){

                speed = speed + increment;
                }

                // to decrease speed
                @Override
                public void applyBrakes(int decrement){

                speed = speed - decrement;
                }

                public void printStates() {
                System.out.println("speed: " + speed
                + " gear: " + gear);
                }
                }

                class Bike implements Vehicle {

                int speed;
                int gear;

                // to change gear
                @Override
                public void changeGear(int newGear){

                gear = newGear;
                }

                // to increase speed
                @Override
                public void speedUp(int increment){

                speed = speed + increment;
                }

                // to decrease speed
                @Override
                public void applyBrakes(int decrement){

                speed = speed - decrement;
                }

                public void printStates() {
                System.out.println("speed: " + speed
                + " gear: " + gear);
                }

                }
                class GFG {

                public static void main (String[] args) {

                // creating an instance of Bicycle
                // doing some operations
                Bicycle bicycle = new Bicycle();
                bicycle.changeGear(2);
                bicycle.speedUp(3);
                bicycle.applyBrakes(1);

                System.out.println("Bicycle present state :");
                bicycle.printStates();

                // creating instance of the bike.
                Bike bike = new Bike();
                bike.changeGear(1);
                bike.speedUp(4);
                bike.applyBrakes(3);

                System.out.println("Bike present state :");
                bike.printStates();
                }
                }
                Output
                Bicycle present state :
                speed: 2 gear: 2
                Bike present state :
                speed: 1 gear: 1
                Advantages of Interfaces in Java

                The advantages of using interfaces in Java are as follows:

                Without bothering about the implementation part, we can achieve
                the security of the implementation.
                In Java, multiple inheritances are not allowed, however, you can
                use an interface to make use of it as you can implement more
                than one interface.
                Multiple Inheritance in Java Using Interface
                Multiple Inheritance is an OOPs concept that can’t be
                implemented in Java using classes. But we can use multiple
                inheritances in Java using Interface. let us check this with an
                example.

                Multiple Inheritance in Java

                Example:

                // Java program to demonstrate How Diamond Problem
                // Is Handled in case of Default Methods

                // Interface 1
                interface API {
                // Default method
                default void show()
                {

                // Print statement
                System.out.println("Default API");
                }
                }

                // Interface 2
                // Extending the above interface
                interface Interface1 extends API {
                }

                // Interface 3
                // Extending the above interface
                interface Interface2 extends API {
                }

                // Main class
                // Implementation class code
                class TestClass implements Interface1, Interface2 {
                // Main driver method
                public static void main(String args[])
                {
                // Creating object of this class
                // in main() method
                TestClass d = new TestClass();

                // Now calling the function defined in interface 1
                // from whom Interface 2and 3 are deriving
                d.show();
                }
                }
                Output
                Default API
                New Features Added in Interfaces in JDK 8
                There are certain features added to Interfaces in JDK 8 update
                mentioned below:

                1. Prior to JDK 8, the interface could not define the
                implementation. We can now add default implementation for
                interface methods. This default implementation has a special use
                and does not affect the intention behind interfaces.

                Suppose we need to add a new function to an existing interface.
                Obviously, the old code will not work as the classes have not
                implemented those new functions. So with the help of default
                implementation, we will give a default body for the newly added
                functions. Then the old codes will still work.

                Below is the implementation of the above point:

                // Java program to show that interfaces can
                // have methods from JDK 1.8 onwards

                interface In1
                {
                final int a = 10;
                default void display()
                {
                System.out.println("hello");
                }
                }

                // A class that implements the interface.
                class TestClass implements In1
                {
                // Driver Code
                public static void main (String[] args)
                {
                TestClass t = new TestClass();
                t.display();
                }
                }
                Output
                hello
                2. Another feature that was added in JDK 8 is that we can now
                define static methods in interfaces that can be called
                independently without an object.

                Note: these methods are not inherited.

                // Java Program to show that interfaces can
                // have methods from JDK 1.8 onwards

                interface In1
                {
                final int a = 10;
                static void display()
                {
                System.out.println("hello");
                }
                }

                // A class that implements the interface.
                class TestClass implements In1
                {
                // Driver Code
                public static void main (String[] args)
                {
                In1.display();
                }
                }
                Output
                hello
                Extending Interfaces
                One interface can inherit another by the use of keyword extends.
                When a class implements an interface that inherits another
                interface, it must provide an implementation for all methods
                required by the interface inheritance chain.

                Program 1:

                interface A {
                void method1();
                void method2();
                }
                // B now includes method1 and method2
                interface B extends A {
                void method3();
                }
                // the class must implement all method of A and B.
                class gfg implements B {
                public void method1()
                {
                System.out.println("Method 1");
                }
                public void method2()
                {
                System.out.println("Method 2");
                }
                public void method3()
                {
                System.out.println("Method 3");
                }
                }
                Program 2:

                interface Student
                {
                public void data();

                }
                class avi implements Student
                {
                public void data ()
                {
                String name="avinash";
                int rollno=68;
                System.out.println(name);
                System.out.println(rollno);
                }
                }
                public class inter_face
                {
                public static void main (String args [])
                {
                avi h= new avi();
                h.data();
                }
                }
                Output
                avinash
                68
                In a Simple way, the interface contains multiple abstract
                methods, so write the implementation in implementation classes.
                If the implementation is unable to provide an implementation of
                all abstract methods, then declare the implementation class with
                an abstract modifier, and complete the remaining method
                implementation in the next created child classes. It is possible
                to declare multiple child classes but at final we have completed
                the implementation of all abstract methods.

                In general, the development process is step by step:

                1. Level 1- interfaces: It contains the service details.

                2. Level 2 – abstract classes: It contains partial
                implementation.

                3. Level 3 – implementation classes: It contains all
                implementation.

                4. Level 4 – Final Code / Main Method: It have access of all
                interfaces data.

                Example:

                // Java Program for
                // implementation Level wise
                import java.io.*;
                import java.lang.*;
                import java.util.*;

                // Level 1
                interface Bank {
                void deposit();
                void withdraw();
                void loan();
                void account();
                }

                // Level 2
                abstract class Dev1 implements Bank {
                public void deposit()
                {
                System.out.println("Your deposit Amount :" + 100);
                }
                }

                abstract class Dev2 extends Dev1 {
                public void withdraw()
                {
                System.out.println("Your withdraw Amount :" + 50);
                }
                }

                // Level 3
                class Dev3 extends Dev2 {
                public void loan() {}
                public void account() {}
                }

                // Level 4
                class GFG {
                public static void main(String[] args)
                {
                Dev3 d = new Dev3();
                d.account();
                d.loan();
                d.deposit();
                d.withdraw();
                }
                }
                Output
                Your deposit Amount :100
                Your withdraw Amount :50
                New Features Added in Interfaces in JDK 9
                From Java 9 onwards, interfaces can contain the following also:

                Static methods
                Private methods
                Private Static methods
                Important Points in Java Interfaces
                In the article, we learn certain important points about
                interfaces as mentioned below:

                We can’t create an instance(interface can’t be instantiated) of
                the interface but we can make the reference of it that refers to
                the Object of its implementing class.
                A class can implement more than one interface.
                An interface can extend to another interface or interface (more
                than one interface).
                A class that implements the interface must implement all the
                methods in the interface.
                All the methods are public and abstract. And all the fields are
                public, static, and final.
                It is used to achieve multiple inheritances.
                It is used to achieve loose coupling.
                Inside the Interface not possible to declare instance variables
                because by default variables are public static final.
                Inside the Interface, constructors are not allowed.
                Inside the interface main method is not allowed.
                Inside the interface, static, final, and private methods
                declaration are not possible.
                Frequently Asked Questions in Interfaces
                1. What is a marker or tagged interface?
                Tagged Interfaces are interfaces without any methods they serve
                as a marker without any capabilities.

                2. How many Types of interface in Java?
                Types of interfaces in Java are mentioned below:

                Functional Interface
                Marker interface
                3. Why multiple inheritance is not supported through class in
                Java?
                Multiple Inheritance is not supported through class in Java so
                to avoid certain challenges like Ambiguity and diamond problems.

                Must Read:
                Access Specifier of Methods in Interfaces
                Access Specifiers for Classes or Interfaces in Java
                Abstract Classes in Java
                Comparator Interface in Java
                Java Interface Methods
                Nested Interface in Java

                Whether you're preparing for your first job interview or aiming
                to upskill in this ever-evolving tech landscape, GeeksforGeeks
                Courses are your key to success. We provide top-quality content
                at affordable prices, all geared towards accelerating your
                growth in a time-bound manner. Join the millions we've already
                empowered, and we're here to do the same for you.</p>
        </div>
        <div id="instance">
            <h1 style="text-align: center;background-color: blue;color: aliceblue;">Intance of</h1>
            <p>The java instanceof operator is used to test whether the object
                is an instance of the specified type (class or subclass or
                interface).

                The instanceof in java is also known as type comparison operator
                because it compares the instance with type. It returns either
                true or false. If we apply the instanceof operator with any
                variable that has null value, it returns false.

                Simple example of java instanceof
                Let's see the simple example of instance operator where it tests
                the current class.

                class Simple1{
                public static void main(String args[]){
                Simple1 s=new Simple1();
                System.out.println(s instanceof Simple1);//true
                }
                }
                Test it Now
                Output:true
                An object of subclass type is also a type of parent class. For
                example, if Dog extends Animal then object of Dog can be
                referred by either Dog or Animal class.

                Another example of java instanceof operator
                class Animal{}
                class Dog1 extends Animal{//Dog inherits Animal

                public static void main(String args[]){
                Dog1 d=new Dog1();
                System.out.println(d instanceof Animal);//true
                }
                }
                Test it Now
                Output:true
                instanceof in java with a variable that have null value
                If we apply instanceof operator with a variable that have null
                value, it returns false. Let's see the example given below where
                we apply instanceof operator with the variable that have null
                value.

                class Dog2{
                public static void main(String args[]){
                Dog2 d=null;
                System.out.println(d instanceof Dog2);//false
                }
                }
                Test it Now
                Output:false
                Downcasting with java instanceof operator
                When Subclass type refers to the object of Parent class, it is
                known as downcasting. If we perform it directly, compiler gives
                Compilation error. If you perform it by typecasting,
                ClassCastException is thrown at runtime. But if we use
                instanceof operator, downcasting is possible.

                Dog d=new Animal();//Compilation error
                If we perform downcasting by typecasting, ClassCastException is
                thrown at runtime.

                Dog d=(Dog)new Animal();
                //Compiles successfully but ClassCastException is thrown at
                runtime
                Possibility of downcasting with instanceof
                Let's see the example, where downcasting is possible by
                instanceof operator.

                class Animal { }

                class Dog3 extends Animal {
                static void method(Animal a) {
                if(a instanceof Dog3){
                Dog3 d=(Dog3)a;//downcasting
                System.out.println("ok downcasting performed");
                }
                }

                public static void main (String [] args) {
                Animal a=new Dog3();
                Dog3.method(a);
                }

                }
                Test it Now
                Output:ok downcasting performed
                Downcasting without the use of java instanceof
                Downcasting can also be performed without the use of instanceof
                operator as displayed in the following example:

                class Animal { }
                class Dog4 extends Animal {
                static void method(Animal a) {
                Dog4 d=(Dog4)a;//downcasting
                System.out.println("ok downcasting performed");
                }
                public static void main (String [] args) {
                Animal a=new Dog4();
                Dog4.method(a);
                }
                }
                Test it Now
                Output:ok downcasting performed
                Let's take closer look at this, actual object that is referred
                by a, is an object of Dog class. So if we downcast it, it is
                fine. But what will happen if we write:

                Animal a=new Animal();
                Dog.method(a);
                //Now ClassCastException but not in case of instanceof operator
                Understanding Real use of instanceof in java
                Let's see the real use of instanceof keyword by the example
                given below.

                interface Printable{}
                class A implements Printable{
                public void a(){System.out.println("a method");}
                }
                class B implements Printable{
                public void b(){System.out.println("b method");}
                }

                class Call{
                void invoke(Printable p){//upcasting
                if(p instanceof A){
                A a=(A)p;//Downcasting
                a.a();
                }
                if(p instanceof B){
                B b=(B)p;//Downcasting
                b.b();
                }

                }
                }//end of Call class

                class Test4{
                public static void main(String args[]){
                Printable p=new B();
                Call c=new Call();
                c.invoke(p);
                }
                } </p>
        </div>
    </body>
</html>